# Unique Exploit - Exit and Free 

이 기법은 흔히 사용하는 exit 함수 내부에서 free 함수가 호출된다는 점을 이용한 기법입니다. (기법 이름은 공식적인건 아닙니다...)

기본적으로 __free_hook을 사용하며, 조건이 갖춰질 경우 공격자가 원하는 함수를 원하는 인자를 넣어(대신 첫번째 인자만) 호출할 수 있습니다.

라이브러리 버전 : glibc 2.27

## exit 함수 코드 분석

```C
// stdlib/exit.c
void exit (int status)
{
  __run_exit_handlers (status, &__exit_funcs, true, true);
}
```

- exit 함수가 호출되면 위와 같이 ```__run_exit_handlers``` 함수가 바로 호출되는 것을 확인할 수 있습니다.

```C
// stdlib/exit.c
void attribute_hidden __run_exit_handlers (int status, struct exit_function_list **listp, bool run_list_atexit, bool run_dtors)
{
  /* First, call the TLS destructors.  */
#ifndef SHARED
    if (&__call_tls_dtors != NULL)
#endif
        if (run_dtors)
            __call_tls_dtors ();

  /* We do it this way to handle recursive calls to exit () made by
     the functions registered with `atexit' and `on_exit'. We call
     everyone on the list and use the status value in the last
     exit (). */
    while (true)
    {
        struct exit_function_list *cur;

        __libc_lock_lock (__exit_funcs_lock);

	restart:
        cur = *listp;

        if (cur == NULL)        // [A] : 우회해야함
        {
        /* Exit processing complete.  We will not allow any more
        atexit/on_exit registrations.  */
            __exit_funcs_done = true;
            __libc_lock_unlock (__exit_funcs_lock);
            break;
        }

        while (cur->idx > 0)    // [B] : 우회해야함
        {
            ...
        }
        
        *listp = cur->next;
        if (*listp != NULL)     // [C] : 들어가야함
        /* Don't free the last element in the chain, this is the statically
        allocate element.  */
            free (cur);         // call free!
        __libc_lock_unlock (__exit_funcs_lock);
    }
    ...
    _exit (status);
}
```

- 위의 ```__run_exit_handlers``` 함수의 코드를 보면 내부에서 free 함수를 호출하는 것을 확인 할 수 있습니다. (필요없는 코드들은 대부분 잘랐습니다)

- free 함수를 빠르게 호출하기 위한 조건은 아래와 같습니다.

  - [A] : ```cur == NULL``` ==> ```*listp != NULL``` 
  - [B] : ```cur->idx > 0``` ==> ```*listp->idx == 0``` 
  - [C] : ```*listp != NULL``` ==> ```cur->next != NULL``` ==> ```*listp->next != NULL```

- 조건에서 사용되는 listp는 ```__run_exit_handlers``` 함수가 두 번째 인자로 받는 인자입니다. 

  이 함수가 인자로 받는 값은 exit 함수를 보면, ```&__exit_funcs```라는 것을 알 수 있습니다. 이 변수는 전역 변수이고 아래과 같이 선언됩니다.

  - ```C
    //stdlib/cxa_atexit.c
    static struct exit_function_list initial;
    struct exit_function_list *__exit_funcs = &initial;
    ```

    위와 같이 initial 이란 이름의 구조체의 주소를 담고있는 포인터라는 것을 알 수 있습니다.

    - 이 initial 구조체는 전역 변수이기 때문에 라이브러리에 심볼이 남아있습니다. 때문에 gdb를 통해 해당 변수에 쉽게 접근할 수 있습니다.

- ```exit_function_list```구조체는 아래와 같습니다.

  - ```C
    // stdlib/exit.h
    struct exit_function_list
    {
        struct exit_function_list *next;
        size_t idx;	// size_t == unsigned int
        struct exit_function fns[32];
    };
    ```

- 이제 조건을 다시 요약해 보면, 아래와 같다는 것을 알 수 있습니다.

  - [A] : ```*listp != NULL```  ==> ```initial != NULL``` : 멤버변수 next의 값이 NULL이 아니어야함.
  - [B] : ```*listp->idx == 0``` ==> ```initial.idx == 0``` : 멤버변수 idx의 값이 0이어야함.
  - [C] : ```*listp->next != NULL``` ==> ```initial.next != NULL``` : 멤버변수 next의 값이 NULL이 아니어야함.

- **결론**적으로 free함수를 exit함수 내부에서 호출하기 위해서는 아래와 같은 **조건을 만족**시켜야 된다는 것입니다.
  - 전역 변수인 initial 구조체의 next 멤버 변수의 값은 NULL이 아니어야 한다. (주소 : *(&initial+0x0) != NULL )
  - 전역 변수인 initial 구조체의 idx 멤버 변수의 값은 NULL이어야 한다. (주소 : *(&initial+0x8) == 0 )



## 그래서 익스는?

free 함수가 호출 되도록 조작 한 이후에는 __free_hook에 원하는 함수의 주소를 덮어 진행 하면 됩니다.

보통은 **oneshot 가젯을 덮는 방법**을 사용하지만, 만약 조건을 맞추지 못한 경우에는 아래와 같은 방법을 사용하여 system함수를 이용한 공격을 할 수 있습니다.

```C
void attribute_hidden __run_exit_handlers (int status, struct exit_function_list **listp, bool run_list_atexit, bool run_dtors)
{
    ...
        cur = *listp;
    ...
            free (cur);         // call free!
    ...
}
```

- 위와같이 __run_exit_handlers함수에서 free함수를 호출하는 부분을 보면, 인자로 cur이 들어간다는 것을 알 수 있습니다.

  cur은 결과적으로 initial 구조체의 주소와 같습니다.

  따라서 만약, __free_hook에 system과 같은 함수를 덮었다면, initial 구조체의 주소(주소 : *(&initial+0x0) )에 "/bin/sh\x00" 문자열을 저장해주면

  ```system("/bin/sh" ```함수를 호출하는 것과 동일한 결과를 얻을 수 있습니다.



## Reference

https://elixir.bootlin.com/glibc/glibc-2.27/source/stdlib/exit.c#L137 - glibc-2.27 exit 함수 소스코드



## 잡소리

사실 이건 bob 10기 필기 시험으로 나온 문제를 다시 풀면서 빼먹었던 부분을 정리한 것이다...

exit 함수 내부에서 free함수를 사용한다는 것까지는 알고있었는데, free 호출하기 위해 조건이 필요하다는것은 모르고 있었다...

시간 촉박함 때문에 괜히 쫄려서 검색도 제대로 못해보고 쉘을 시간이 지나고나서 딴게 너무 아쉽다...

다음에는 이런일 없도록 해야지...