# TCACHE (구 버전)

tcache는 glibc 2.26 버전부터 생긴 새로운 bin이다. (대충 ubuntu 18.04이상 버전: _실제로 ubuntu 18.04은 glibc 2.27을 사용한다. ~~(근데 마찬가지임)~~_)

작은 크기의 chunk들에 대하여(fast bin, small bin size) 오로지 빠른 재할당 만을 위해 생겨났기 때문에 매우매우매우 취약하다는 점이 있다. (무지성 재할당;;)

그랬으나... 2021년 2월 경 기존의 glibc들에 대하여 보안 패치가 되면서 현재 기준으로 glibc 2.27 최신 버전은 glibc 2.29버전와 같은 수준의 보안 패치가 되어있다.

즉, 더이상 무지성으로 취약하지만은 않다... (glibc 2.26은 안써봐서 모르겠네요...)

이번글에서는 취약했던 구 버전에서의 TCACHE에 대해 정리를 해보겠다. 

(구 버전을 하는 이유는 아직 많은 워게임들에서는 서버에 구버전의 glibc 2.27을 사용하는 문제들이 많기 때문에 알아둬야함...)



## TCACHE의 관리

기존의 bin 들은 arena에 의해 관리가 되었었지만, tcache는 다르다.

tcache는 ```tcache_perthread_struct```에 의해 관리된다. 

이 ```tcache_perthread_struct```는 언재나 **heap 영역의 가장 낮은 주소**에 존재하는데, 이는 __libc_malloc 함수에서 ```MAYBE_INIT_TCACHE ();```매크로를 호출하여 가장먼저 초기화시키기 때문이다.

```c
#define MAYBE_INIT_TCACHE() \
  if (__glibc_unlikely (tcache == NULL)) \
    tcache_init();
```

만약, malloc을 호출한 경우 heap 영역에 ```tcache_perthread_struct```가 초기화 되어있지 않으면 ```tcache_init();``` 함수를 호출하여 ```tcache_perthread_struct```를 동적 할당한다. 때문에 항상 가장 낮은 주소에 존재하는 것이다.

```C
// # define TCACHE_MAX_BINS		64
typedef struct tcache_perthread_struct
{
  char counts[TCACHE_MAX_BINS];				
  tcache_entry *entries[TCACHE_MAX_BINS];
} tcache_perthread_struct;
// tcache_perthread_struct는 heap 영역에 0x250 size(x64기준. glibc 2.27 기준. 헤더 포함 크기)의 청크로 할당된다. 

typedef struct tcache_entry	
{
  struct tcache_entry *next;	// 링크 포인터
} tcache_entry;
```

- tcache_entry로 연결리스트를 사용한다. 링크 포인터가 하나밖에 없는 것을 볼 수 있는데, 이는 tcache는 단일 연결 리스트(single linked list)이기 때문이다.

- tcache는 fast bin과 같은 LIFO 형식을 사용한다.

- 크기 별로 맨 처음으로 tcache에 들어간 freed chunk는 next 포인터가 NULL이다.

- counts 배열은 같은 크기의 tcache bin에 들어간 freed chunk의 갯수를 저장한다.

- entries 배열에는 각 크기별 가장 마지막에 해제된 chunk의 주소를 가지고 있다. entries의 값을 가지고 재할당 할 chunk의 주소를 알아내기 때문이다.

  - ```
    # heap memory 
    pwndbg> tcachebins
    tcachebins
    0x20 [  2]: 0x555555756280 —▸ 0x555555756260 ◂— 0x0
    0x30 [  2]: 0x5555557562d0 —▸ 0x5555557562a0 ◂— 0x0
    pwndbg> x/40gx 0x555555756000
    0x555555756000: 0x0000000000000000      0x0000000000000251  <-- tcache_perthread_struct chunk
    0x555555756010: 0x0000000000000202      0x0000000000000000  --
    0x555555756020: 0x0000000000000000      0x0000000000000000    | <-- counts
    0x555555756030: 0x0000000000000000      0x0000000000000000    |
    0x555555756040: 0x0000000000000000      0x0000000000000000  --
    0x555555756050: 0x0000555555756280      0x00005555557562d0  --
    0x555555756060: 0x0000000000000000      0x0000000000000000    | <-- entries
    0x555555756070: 0x0000000000000000      0x0000000000000000    |
    0x555555756080: 0x0000000000000000      0x0000000000000000 ...
    ```
    
    - 위의 상황은 0x20 크기의 chunk 2개와 0x30 크기의 chunk 2개를 해제한 상태일때의 ```tcache_perthread_struct->counts``` 부분의 힙 메모리이다.
    
      - 크기는 헤더를 포함한 크기이다.
    - counts 배열에 대한 것
      - 0x555555756010의 값 0x2는 0x20크기의 해제된 청크에 대한 것이고
      - 0x555555756011의 값 0x2는 0x30크기의 해제된 청크에 대한 것이다.
      - 즉, 1byte당 크기별로 count되는 자리(index)가 있다는 것을 알 수 있다.
    - entries 배열에 대한 것
      - 0x555555756050의 값 0x555555756050은 0x20 크기의 해제된 청크 중 가장 마지막으로 해제된 chunk의 주소이다.
      - 0x555555756058의 값 0x5555557562d0은 0x30 크기의 해제된 청크 중 가장 마지막으로 해제된 chunk의 주소이다.
      - 즉, entries도 counts와 마찬가지로 크기 별로 표시되는 자리(index)가 있다는 것을 알 수 있다.

## TCACHE의 사용
tcache는 ``tcache_put()``함수를 통해 **tache bin에 추가**를 하고, ```tcache_get()``` 함수를 통해 **tcache bin에서 가져온다.**

이때 각 함수의 호출 조건을 mp_구조체의 값과 비교를 한다.

### mp_ 구조체

```C
// mp_ 구조체
# define TCACHE_FILL_COUNT 7
# define TCACHE_MAX_BINS   64
static struct malloc_par mp_ =
{
	...
#if USE_TCACHE
  ,
  .tcache_count = TCACHE_FILL_COUNT,		// tcache는 같은 크기당 7개씩 관리한다.
  .tcache_bins = TCACHE_MAX_BINS,			// tcache bin은 최대 64개까지 존재한다.
  .tcache_max_bytes = tidx2usize (TCACHE_MAX_BINS-1),
  .tcache_unsorted_limit = 0 /* No limit.  */
#endif
};
```

- mp_구조체에서 크게 중요한건 다음 2가지이다.
  - tcache는 같은 크기당 7개씩 관리한다.
  -  tcache bin은 최대 64개까지 존재한다.

### tcache_put 함수

```C
static void tcache_put (mchunkptr chunk, size_t tc_idx)
{
  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
  assert (tc_idx < TCACHE_MAX_BINS);
  e->next = tcache->entries[tc_idx];
  tcache->entries[tc_idx] = e;			// tcache->entries에 저장
  ++(tcache->counts[tc_idx]);
}
```
이 코드에서 중요한 점은 tcache에 추가할때 이미 들어가 있는 chunk인지 아무런 검증을 안한다는 것이다. 이 때문에 쉽게 double free를 할 수 있다.
- ### tache_put 함수가 호출되는 상황

```C
// in _int_malloc()
# define TCACHE_MAX_BINS		64
# define csize2tidx(x) (((x) - MINSIZE + MALLOC_ALIGNMENT - 1) / MALLOC_ALIGNMENT)

// in fast bin alloc
#if USE_TCACHE
	/* While we're here, if we see other chunks of the same size,
    stash them in the tcache.  */
	size_t tc_idx = csize2tidx (nb);
	if (tcache && tc_idx < mp_.tcache_bins)
	{
	    mchunkptr tc_victim;

	    /* While bin not empty and tcache not full, copy chunks over.  */
	    while (tcache->counts[tc_idx] < mp_.tcache_count && (pp = *fb) != NULL)
		{
			REMOVE_FB (fb, tc_victim, pp);
			if (tc_victim != 0)
			{
			    tcache_put (tc_victim, tc_idx);
	        }
		}
	}
#endif

// in small bin alloc 
#if USE_TCACHE
	  /* While we're here, if we see other chunks of the same size,
	     stash them in the tcache.  */
		size_t tc_idx = csize2tidx (nb);
		if (tcache && tc_idx < mp_.tcache_bins)
		{
			mchunkptr tc_victim;

            /* While bin not empty and tcache not full, copy chunks over.  */
            while (tcache->counts[tc_idx] < mp_.tcache_count && (tc_victim = last (bin)) != bin)
			{
				if (tc_victim != 0)
				{
					bck = tc_victim->bk;
				    set_inuse_bit_at_offset (tc_victim, nb);
				    if (av != &main_arena)
						set_non_main_arena (tc_victim);
				    bin->bk = bck;
				    bck->fd = bin;
                    
				    tcache_put (tc_victim, tc_idx);
				}
			}
		}
#endif

// in unstored bin alloc
#if USE_TCACHE
		/* Fill cache first, return to user only if cache fills.
		 We may return one of these chunks later.  */
					if (tcache_nb && tcache->counts[tc_idx] < mp_.tcache_count)
					{
						tcache_put (victim, tc_idx);
						return_cached = 1;
						continue;
					}
				    else
					{
#endif
```

- _int_malloc() 함수에 의하여 호출된 경우는 아래와 같은 경우이다.

  - fast bin size의 청크를 **재할당**하는 경우 : 만약 tcache에 자리가 남아있고, fast bin에 해제된 청크가 들어 있는 경우, REMOVE_FB 매크로 함수로 fast bin에 남아있는 청크들을 병합한 후 tcache bin에 넘긴다.
  - small bin size의 청크를 **재할당**하는 경우 : fast bin과 같이 만약 tcache에 자리가 남아있고, small bin에 해제된 청크가 들어 있는 경우, small bin에 남은 청크들을 tcache bin에 넘긴다.
  - unsorted bin에서 청크를 **재할당**하는 경우 : fast bin, small bin과 같은 로직으로 사용된다. 단, smallbin과 fastbin과 다르게 return_cached변수에 1로 세팅한다.

```C
// in _int_free()
/*
[변수 정리]
tcache : tcache_perthread_struct의 주소
*/
#if USE_TCACHE
{
    size_t tc_idx = csize2tidx (size);

    if (tcache && tc_idx < mp_.tcache_bins && tcache->counts[tc_idx] < mp_.tcache_count)	
    {
		tcache_put (p, tc_idx);
		return;
    }
}
#endif
```

- _int_free() 함수에 의하여 호출되는 특징
  - fast bin, small bin보다 먼저 tcache bin에서 먼저 찾는다.
  - 호출 조건 : (```if (tcache && tc_idx < mp_.tcache_bins && tcache->counts[tc_idx] < mp_.tcache_count)```)
    - ```tcache``` : tcache_perthread_struct가 초기화 되어있음.
    - ```tc_idx < mp_.tcache_bins``` : tc_idx값이 64보다 작음.
    - ``` tcache->counts[tc_idx] < mp_.tcache_count ```  : 같은 크기의 tcache bin의 갯수가 7보다 적음.

### tcache_get 함수

```C
static void *tcache_get (size_t tc_idx)
{
  tcache_entry *e = tcache->entries[tc_idx];		// tcache->entries에서 청크를 가져옴
  assert (tc_idx < TCACHE_MAX_BINS);
  assert (tcache->entries[tc_idx] > 0);
  tcache->entries[tc_idx] = e->next;				// tcache bin에서 다음 청크로 연결 (현재 청크를 tcache bin에서 빼버림)
  --(tcache->counts[tc_idx]);
  return (void *) e;
}
```

tcache_put의 코드와 마찬가지로 tcache_get 함수도 별다른 검증이 없이 청크의 주소를 가져온다.

- ### tcache_get 함수가 호출되는 상황

```C
void * __libc_malloc (size_t bytes)
{
	mstate ar_ptr;
	void *victim;

	void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook);
	if (__builtin_expect (hook != NULL, 0))
		return (*hook)(bytes, RETURN_ADDRESS (0));
    
#if USE_TCACHE
  	/* int_free also calls request2size, be careful to not pad twice.  */
  	size_t tbytes = request2size (bytes);
  	size_t tc_idx = csize2tidx (tbytes);

  	MAYBE_INIT_TCACHE ();

  	DIAG_PUSH_NEEDS_COMMENT;
  	if (tc_idx < mp_.tcache_bins
    /*&& tc_idx < TCACHE_MAX_BINS*/ /* to appease gcc */
    && tcache
    && tcache->entries[tc_idx] != NULL)
    {
    	return tcache_get (tc_idx);
	}
	DIAG_POP_NEEDS_COMMENT;
#endif
    arena_get (ar_ptr, bytes);
	
    victim = _int_malloc (ar_ptr, bytes);
    ...
}
```

- tcache_get 함수는 __libc_malloc 함수에서 호출된다. (\_int_malloc을 호출하는 함수)

- 호출 조건은 아래와 같다.

  - ```tc_idx < mp_.tcache_bins``` : tc_idx 값이 64보다 작음.

  - ```tcache``` : tcache_perthread_struct가 초기화 되어 있음.

  - ```tcache->entries[tc_idx] != NULL```  : 요청 크기의 tcache bin이 있음.

- 위의 호출 조건 같이 victim 청크의 size값도 체크를 안하기 때문에 쉽게 fake chunk를 만들 수 있음. (아무런 보호 기법이 없음. 익스 개꿀!)

- tcache_get 함수는 __int_malloc 보다 먼저 호출된다.

  


## TCACHE의 특징 정리

- fast bin, small bin 크기의 청크가 free된 경우, **가장 최우선 적**으로 tcache에 들어간다.
- tcache는 해제했을 경우, **인접한 freed chunk와 병합하지 않는다.** 
- tcache는 **병합하지 않기 때문에 prev_size나 prev_inuse_bit를 셋팅하지 않는다.** 해제된 tcache  chunk에는 그저 자신의 size와 next만 존재한다.
- fast bin과 같은 **single linked list로 LIFO**를 한다.
- fastbin에서 fd는 다음 청크의 prev_size를 가리키지만 **tcache에서 next는 다음 청크의 next부분을 가리킨다.**
- **tcache_perthread_struct에서 관리**한다.
- **같은 크기의 tcache bin들은 최대 7개까지 저장**된다. (이후에는 크기에 맞는 fast bin, small bin, unsorted bin에 들어감.)
- tcache에서 관리하는 **bin들의 최대 갯수는 64개**이다.
- fast bin, small bin, unsorted bin에 저장되어 있는 해제된 청크를 **재할당하는데 사용하는 경우**, **tcache bin에 자리가 있는 경우**, **bin에 남은 해제된 청크들을 tcache bin으로 넘긴다.**

## Reference

dreamhack.io - 강의

https://rninche01.tistory.com/entry/heap5-tcacheThread-local-Caching

https://krrr-1.tistory.com/23
