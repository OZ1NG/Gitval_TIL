# House of Orange (작성 중...)

House of Orange 기법은 복잡합니다.

해커가 Top chunk의 prev_size, fd, bk를 덮을 수 있고 해당 청크에 데이터를 입력할 수 있을때 이 기법을 사용 할 수 있습니다.

요약하면 일부러 에러를 일으키는 상황을 만들어, malloc_printerr를 호출시키고, malloc_printerr함수 내부에 있는 fflush를 호출시켜 FSOP를 이용해 원하는 주소를 호출시키는 방법입니다.

### 공격 흐름

### 1. Unsorted Bin 만들기

Unsorted Bin은 Top Chunk를 이용해서 만듭니다.

```C
// _int_malloc()
static void * _int_malloc (mstate av, size_t bytes)
{
    INTERNAL_SIZE_T nb;               /* normalized request size */
    ...
    checked_request2size (bytes, nb);	// nb에 정제된 size를 저장.(실제로 할당할 크기)
    ...
	victim = av->top;
	size = chunksize (victim);

    /*
    현재 top chunk의 size가 (실제로 할당할 크기+최소 사이즈(=0x10))보다 크거나 같은 경우,
    top chunk에서 새로운 청크를 할당함. (일반적인 경우)
    (최소사이즈를 더하는 이유는 실제 요청크기 + 헤더 크기를 포함하기 위함임.)
    */
    if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))
    {
        ...
    }
    /* 
    When we are using atomic ops to free fast chunks we can get here for all block sizes. 
    만약 fast bin 청크들이 있는경우 병합함. (주소를 리턴한다던가 그런건 없슴.)
    */
    else if (have_fastchunks (av))
    {
        malloc_consolidate (av);
        /* restore original bin index */
        if (in_smallbin_range (nb))
            idx = smallbin_index (nb);
        else
            idx = largebin_index (nb);
    }
    /*
    Otherwise, relay to handle system-dependent cases
    만약, fastbin 청크도 없는데 top chunk의 size값이 할당하려는 크기보다 작다면
    sysmalloc을 호출하여 힙영역을 늘리고 거기다가 요청받은 사이즈 만큼 할당함.
    */
    else
    {
        void *p = sysmalloc (nb, av);	// [A] : 여기서 Unsorted Bin이 만들어짐.
        if (p != NULL)
            alloc_perturb (p, bytes);
        return p;
    }
}
```

```C
/*
   sysmalloc handles malloc cases requiring more memory from the system.
   On entry, it is assumed that av->top does not have enough
   space to service request for nb bytes, thus requiring that av->top
   be extended or replaced.
   설명 : sysmalloc은 top chunk에 더이상 충분한 공간이 없는 경우 top chunk를 
   연장하여(=힙 영역을 늘려서) nb값(할당 요청받은 크기)만큼을 할당시켜 줍니다.
 */
static void * sysmalloc (INTERNAL_SIZE_T nb, mstate av)
{
    /*
    av값이 NULL이거나(= 힙영역이 없는 상황인 경우) 또는
    할당할 size값(nb)이 mmap으로 할당하는 최소크기(mp_.mmap_threshold)보다 크고
    mmap으로 할당가능한 최대 크기(mp_.n_mmaps_max)보다 작은 경우(= mmap으로 할당 가능한 경우),
    mmap으로 확장 시도.
    */ 
    if (av == NULL
      || ((unsigned long) (nb) >= (unsigned long) (mp_.mmap_threshold)
	  && (mp_.n_mmaps < mp_.n_mmaps_max)))
    {
        ...
    }
    // av값이 NULL이면 리턴 (힙영역이 없는 최초 상황인 경우)
    if (av == NULL)
        return 0;
    
    /* 
    assert는 꼭 맞춰줘야하는 조건임
    중요한 부분은 그냥 top chunk의 prev_inuse_bit값이 1이여야 한다는 것 정도?
    그리고 old_end & (pagesize-1) 조건 때문에 이전까지 할당된 모든 chunk의 size값과 top chunk의 size값이 0x1000의 배수가 되어야한다함.
    */
    assert ((old_top == initial_top (av) && old_size == 0) ||
            ((unsigned long) (old_size) >= MINSIZE &&
             prev_inuse (old_top) &&
             ((unsigned long) old_end & (pagesize - 1)) == 0));
    /* Precondition: not enough current space to satisfy nb request */
    assert ((unsigned long) (old_size) < (unsigned long) (nb + MINSIZE));

    /* Record incoming configuration of top */
    old_top = av->top;
    old_size = chunksize (old_top);
    old_end = (char *) (chunk_at_offset (old_top, old_size));

    /*
    여기부터는 sbrk를 통해 현재 힙 영역을 늘려줌.
    */
    brk = snd_brk = (char *) (MORECORE_FAILURE);
    ...
    // arena가 main_arena가 아닌경우
    if (av != &main_arena)
    {
        ...
    }
    /* 
    arena가 main_arena인 경우, 
    (현재 top chunk의 주소 + 현재 top chunk의 size값)에 sbrk를 이용해 
    힙영역을 추가로 늘려주고 난 뒤 추가로 생성된 부분을 새로운 top chunk로 설정.
    기존 top chunk는 할당도, free도 안된 애매한 상태이기 때문에 free를 해버림.
    */
    else     /* av == main_arena */
    { /* Request enough space for nb + pad + overhead */
  		...
        /* Adjust top based on results of second sbrk */
        if (snd_brk != (char *) (MORECORE_FAILURE))
        {
            // sbrk를 통해 힙 영역을 늘려준 후 새롭게 생성된 부분을 av->top에 저장하는 코드.
            av->top = (mchunkptr) aligned_brk;
            set_head (av->top, (snd_brk - aligned_brk + correction) | PREV_INUSE);
            av->system_mem += correction;
            if (old_size != 0)
            {
                ...
                /* If possible, release the rest. */
                if (old_size >= MINSIZE)
                {
                    _int_free (av, old_top, 1);	// [B] : Unsorted Bin을 만드는 핵심!
                }
            }
        ...
    }
    
    ...

    /* finally, do the allocation */
    /*
    힙 영역 늘리기가 끝난 후, 새롭게 생긴 Top chunk에서 요청받은 사이즈의 청크를 할당하는 부분임.
    */
    p = av->top;
    size = chunksize (p);
    
    /* check that one of the above allocation paths succeeded */
    if ((unsigned long) (size) >= (unsigned long) (nb + MINSIZE))
    {
        remainder_size = size - nb;
        remainder = chunk_at_offset (p, nb);
        av->top = remainder;
        set_head (p, nb | PREV_INUSE | (av != &main_arena ? NON_MAIN_ARENA : 0));
        set_head (remainder, remainder_size | PREV_INUSE);
        check_malloced_chunk (av, p, nb);
        return chunk2mem (p);
    }
    
    /* catch all failure paths */
    __set_errno (ENOMEM);
    return 0;
}
```

- 만약 Top chunk의 size값이 small bin 이상의 크기이고, Top chunk의 size 값보다 더 큰 값을 사용자가 요청한 경우 [A],  [B]에 의하여 기존의 Top chunk의 주소는 Unsorted Bin에 들어가게 됩니다.

  - [A] : _int_malloc 함수 내부에서 Top chunk의 size 값보다 더 큰 값을 요청한 경우, sysmalloc을 호출함.

  - [B] : sysmalloc 함수 내부에서 mmap 또는 sbrk를 이용하여 힙 영역을 늘리고, 기존의 top chunk를 해제함.

    - 이때, 기존의 Top chunk의 size가 small bin의 크기 이상이라면, ```_int_free (av, old_top, 1);```를 하면서 

      기존의 Top chunk의 주소가 Unsorted Bin에 들어가게 됨.

- Top chunk를 Unsorted Bin으로 만들기 위한 조건은 다음과 같습니다.

  - Top Chunk의 size 값을 small bin 이상 크기로 수정. 
    - 단, 이전까지 할당된 청크들의 size값과 top chunk의 size값을 합한 값이 0x1000의 배수가 되어야함.
    - 이때 size값에는 prev_inuse_bit가 설정되어 있어야함. (안그러면 sysmalloc()에서 assert 조건에 의해 종료되어버림.)
  - Top Chunk의 size 값 보다 더 큰 값으로 할당 요청.

- 만약 large bin 이상의 크기로 만든다면, fd_nextsize와 bk_nextsize에 large bin에 들어간 값을 이용하여 leak하는데 사용할 수도 있습니다.

### 2. malloc_printerr 호출 시키기





### 3. fflush 호출 시키기

- malloc_printerr -> __libc_message -> abort 내의 fflush를 호출시킨다.

- 이때의 fflush는 _IO_flush_all_lockp이다.

  - 현재기준 가장 최신버전에서는 abort함수에서 fflush를 호출할때 더이상 _IO_flush_all_lockp를 호출하지는 않는다고 합니다.

    (최신버전에서는 house of orange를 못씀...)



### 4. Unsorted Bin Attack

FSOP를 하기 위해 unsorted bin attack으로_IO_list_all의 값을 덮어줍니다.

- 기존 top chunk의 bk를 _IO_list_all의 주소-0x10으로 수정합니다.
- 기존의 _IO_list_all에는 stderr의 주소가 담겨있습니다. 이 것을 fake file stream의 주소로 변경해주기 위함입니다.

이 공격을 진행하면 _IO_list_all에는 &main_arena+88가 들어가게 됩니다.

&main_arena+88을 기준으로 _IO_list_all->\_chain에는 small bin[4]이 위치하고 있습니다.

따라서 기존의 top chunk의 size값을 0x61(small bin[4]에 해당하는 size)로 수정해준 후 malloc을 하게 되면, 

기존의 top chunk가 small bin[4]에 들어가게 되고, 이 후 malloc_printerr 에 의해 _IO_flush_all_lock가 호출된 다음, ```fp = fp->_chain``` 코드에 의하여 

결과적으로 fp값을 기존의 top chunk로 수정할 수 있게 됩니다.



### 5. SFOP vtable overflow



## 정리

