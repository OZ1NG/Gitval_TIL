# TCACHE (신 버전)

취약했던 기존버전에서 tcache에 대한 보호기법이 추가된 glibc 2.29버전에서의 tcache에 대해 정리했습니다.

그리고 추가로 unsorted bin 등 새롭게 추가된 heap 관련 보호기법에 대해서도 정리했습니다.

시간이 없어서 구 버전 코드와의 비교는 생략하니 필요하면 같이 띄워놓고 비교하면 됨미다........



## 변경된 TCACHE의 관리

### tcache_entry 구조체

```C
// GLIBC 2.29
typedef struct tcache_entry
{
  struct tcache_entry *next;
  /* This field exists to detect double frees.  */
  struct tcache_perthread_struct *key;
} tcache_entry;
```

- tcache_entry 구조체에 기존에는 없던 ```struct tcache_perthread_struct *key;``` 멤버 변수가 추가되었습니다.
- ```struct tcache_perthread_struct *key;``` 멤버 변수는 tcache_perthread_struct chunk의 주소를 저장하고 있습니다. 
  - 청크가 해제되는 경우에 key 값이 저장되고 재할당 되는 경우에는 NULL로 초기화됨.
  - tcache_perthread_struct chunk->counts 멤버 배열 변수의 주소를 저장함.
  - 모든 tcache bin chunk가 동일한 값을 가지고 있습니다. 
- ```struct tcache_perthread_struct *key;``` 멤버 변수는 주석에 써있는 것처럼 tcache double free를 탐지하기 위해 생긴 변수입니다.

- double free 검증 방식

  - ```C
    // _int_free 함수
    tcache_entry *e = (tcache_entry *) chunk2mem (p);
    /* This test succeeds on double free.  However, we don't 100%
       trust it (it also matches random payload data at a 1 in
       2^<size_t> chance), so verify it's not an unlikely
       coincidence before aborting.  */
    if (__glibc_unlikely (e->key == tcache))	// [A]
    {
    	tcache_entry *tmp;
    	LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
    	for (tmp = tcache->entries[tc_idx]; tmp; tmp = tmp->next)
    		if (tmp == e)
    			malloc_printerr ("free(): double free detected in tcache 2");
    			/* If we get here, it was a coincidence.  We've wasted a
    			   few cycles, but don't abort.  */
    }
    ```

  - double free를 검증하는 방식은 다음과 같습니다.

    - [A] : e->key의 값이 tcache(tcache_perthread_struct chunk의 주소)와 같으면 double free로 간주한다.
    - _int_free 함수가 호출되어 tcache 해제를 하는 경우, e->key 변수에 값이 존재하면, 이미 해제가 되어 있다는 것이므로 double free라고 판단.

### tcache_put 함수

```C
static __always_inline void
tcache_put (mchunkptr chunk, size_t tc_idx)
{
  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
  assert (tc_idx < TCACHE_MAX_BINS);
  
  /* Mark this chunk as "in the tcache" so the test in _int_free will
  detect a double free.  */
  e->key = tcache;	// [A]
  
  e->next = tcache->entries[tc_idx];
  tcache->entries[tc_idx] = e;
  ++(tcache->counts[tc_idx]);
}
```

- tcache_put함수에서 이전과 달라진 부분은 [A] 부분이 추가된 것이 끝입니다.
- [A] 코드는 _int_free 함수에서 double free를 탐지하기 위해 생긴 코드입니다. 
- [A]에서는 e->key에 tcache 포인터, 즉 tcache_entiry 구조체의 주소를 저장합니다.



### tcache_get 함수

```C
static __always_inline void *
tcache_get (size_t tc_idx)
{
  tcache_entry *e = tcache->entries[tc_idx];
  assert (tc_idx < TCACHE_MAX_BINS);
  assert (tcache->entries[tc_idx] > 0);
  tcache->entries[tc_idx] = e->next;
  --(tcache->counts[tc_idx]);
    
  e->key = NULL;	// [A]
    
  return (void *) e;
}
```

- tcache_get함수에서 이전과 달라진 부분은 [A] 부분이 추가된 것이 끝입니다.
- [A] 코드는 e->key에 NULL을 저장합니다.



## Unsorted Bin의 검증 추가

기존의 Unsorted Bin에 대한 보호 기법이 부족해 많이 취약했던 점들이 패치되었습니다.

```C
// _int_malloc() 기존의 Unsorted Bin에 대한 취약한 검증 코드
if (__glibc_unlikely (fwd->bk != bck))
{
    errstr = "malloc(): corrupted unsorted chunks";
    goto errout;
}
```

```C
// _int_malloc() 새로 추가된 Unsorted Bin에 대한 검증 코드

// [A]
if (__glibc_unlikely (size <= 2 * SIZE_SZ) || __glibc_unlikely (size > av->system_mem))
	malloc_printerr ("malloc(): invalid size (unsorted)");

// [B]
if (__glibc_unlikely (chunksize_nomask (next) < 2 * SIZE_SZ) || __glibc_unlikely (chunksize_nomask (next) > av->system_mem))
	malloc_printerr ("malloc(): invalid next size (unsorted)");

// [C]
if (__glibc_unlikely ((prev_size (next) & ~(SIZE_BITS)) != size))
	malloc_printerr ("malloc(): mismatching next->prev_size (unsorted)");

// [D]
if (__glibc_unlikely (bck->fd != victim) || __glibc_unlikely (victim->fd != unsorted_chunks (av)))
	malloc_printerr ("malloc(): unsorted double linked list corrupted");

// [E]
if (__glibc_unlikely (prev_inuse (next)))
	malloc_printerr ("malloc(): invalid next->prev_inuse (unsorted)");
```

- [A] : 재할당 받는 청크의 size값이 할당 가능한 최소 값(```2 * SIZE_SZ```)보다 작거나 할당 가능한 최대 값(```av->system_mem```) 보다 큰 경우 에러
- [B] : Unsorted Bin에서 재할당 받을 청크와 인접한 다음 청크의 size 값을 구해 할당 가능한 최소 값(```2 * SIZE_SZ```)보다 작거나 할당 가능한 최대 값(```av->system_mem```) 보다 큰 경우 에러
- [C] : 재할당 받을 청크와 인접한 다음 청크의 `prev_size` 필드의 값을 구한 후 요청한 `size`와 다르면 에러
- [D] : victim(재할당 받을 청크)과 bck->fd가 다르거나, victim->fd가 unsorted bin이 아니라면 에러
  - 이 검증에서 bck->fd를 체크하기 때문에 기존의 Unsorted Bin Attack 기법을 사용할 수 없다.
- [E] : 재할당 받을 청크와 인접한 다음 청크의 prev_inuse_bit가 0이 아니라면 에러



## Top Chunk의 검증 추가

```c
// _int_malloc() 내부
victim = av->top;
size = chunksize (victim);
if (__glibc_unlikely (size > av->system_mem))
    malloc_printerr ("malloc(): corrupted top size");
```

- 변경 이전에는 Top chunk의 size값을 체크하지 않아 House of Force 기법을 사용할 수 있었지만, 이제는 Top chunk의 size값을 체크 하는 코드가 생겨 더 이상 해당 기법을 사용하지 못하게 되었습니다. (제일 좋아하는 기법이었는데... ㅠ)

- Top chunk의 size값이 할당 가능한 최대 값(```av->system_mem```)보다 큰 경우 에러



## global_max_fast의 변경

```c
#define MAX_FAST_SIZE     (80 * SIZE_SZ / 4)
```

```C
//global_max_fast glibc 2.26
#define set_max_fast(s) \
  global_max_fast = (((s) == 0)						      \
                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) & ~MALLOC_ALIGN_MASK))
#define get_max_fast() global_max_fast

//global_max_fast glibc 2.29
static inline INTERNAL_SIZE_T get_max_fast (void)
{
  /* Tell the GCC optimizers that global_max_fast is never larger
     than MAX_FAST_SIZE.  This avoids out-of-bounds array accesses in
     _int_malloc after constant propagation of the size parameter.
     (The code never executes because malloc preserves the
     global_max_fast invariant, but the optimizers may not recognize
     this.)  */
  if (global_max_fast > MAX_FAST_SIZE)
    __builtin_unreachable ();
  return global_max_fast;
}
```

- fast bin에서 허용할 수 있는 최대 크기 값을 가진 변수입니다. 
  - 기존에는 없던 변수입니다.
- 기존에는 이러한 점에 대해 별다른 검증이 없었기 때문에 이 값을 조작하여 어떤 size던 전부 fast bin에 속하게 만들 수 있었습니다.
  - 처음알았네요.. ㄷㄷ
- glibc 2.29부터는 get_max_fast 함수가 새롭게 정의되었습니다.



## 병합(consolidate)의 검증 추가

```C
// glibc 2.26
/* consolidate backward */
if (!prev_inuse(p)) {
    prevsize = prev_size (p);
    size += prevsize;
    p = chunk_at_offset(p, -((long) prevsize));
    unlink(av, p, bck, fwd);    
}
//-------------------------------------------------
// glibc 2.29
/* Treat space at ptr + offset as a chunk */
#define chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))

/* consolidate backward */
if (!prev_inuse(p)) {
    prevsize = prev_size (p);
    size += prevsize;
    p = chunk_at_offset(p, -((long) prevsize));	
    
    if (__glibc_unlikely ((p) != prevsize))	// [A]
        malloc_printerr ("corrupted size vs. prev_size while consolidating");
    
    unlink_chunk (av, p);
}
```

- [A] : **병합 대상인 chunk(지금 해제된 chunk)의 prev_size 값**과 **인접한 더 낮은 주소의 chunk의 size값**이 다르면 에러

- 이 검증으로인해 Poison NULL Byte 기법을 통한 공격이 불가능해졌습니다.

  - Poison Null Byte 기법은 인접한 높은 주소의 청크의 size의 LSB를 0x00으로 덮어 기존의 size값이 바뀌게됨.

  - ~~Poison Null Byte 기법과 함께 자주 사용하는 Unsafe Unlink 기법 또한 불가능해졌다고합니다.~~

    - ~~Unsafe Unlink 기법 : 해제된 청크가 재할당 될때, 연결리스트에서 해당 청크를 해제할때 매크로 함수인 Unlink를 이용해서 연결리스트에서 빼게되는데, 이때 Unlink 매크로 함수에 fd와 bk가 올바른지에 대한 검증이 부족하여 원하는 위치에 청크를 재할당 할 수 있는 기법.~~

      ~~병합을 하게 되는 경우 병합 대상인 청크를 연결리스트에서 제거하기 위해 Unlink도 같이 진행되게 되는데 이 때문에 Unsafe Unlink 기법을 사용못하게 되었다고 하는 듯합니다...~~

    줄친 부분은 검증이 필요한것 같습니다... (아닌것같은데...)

## Reference

https://dreamhack.io/learn/34#4 - Dreamhack.io 강의

