# Tcache Double Free Bypass in glibc 2.29

Tcache에 대한 보호 기법이 생긴 최신버전의 tcache에 대하여 double free를 우회하는 방법에 대한 정리입니다.



## 우회

```C
static __always_inline void tcache_put (mchunkptr chunk, size_t tc_idx)
{
  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);
  assert (tc_idx < TCACHE_MAX_BINS);
    
  /* Mark this chunk as "in the tcache" so the test in _int_free will
     detect a double free.  */
  e->key = tcache;
    
  e->next = tcache->entries[tc_idx];
  tcache->entries[tc_idx] = e;
  ++(tcache->counts[tc_idx]);
}
```

- tcache에서 double free를 검증 하는 방식은 아래와 같습니다.

  - ```C
    // _int_free 함수 내부
    tcache_entry *e = (tcache_entry *) chunk2mem (p);
    /* This test succeeds on double free.  However, we don't 100%
       trust it (it also matches random payload data at a 1 in
       2^<size_t> chance), so verify it's not an unlikely
       coincidence before aborting.  */
    if (__glibc_unlikely (e->key == tcache))	// [A]
    {
    	tcache_entry *tmp;
    	LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);
    	for (tmp = tcache->entries[tc_idx]; tmp; tmp = tmp->next)
    		if (tmp == e)
    			malloc_printerr ("free(): double free detected in tcache 2");
    			/* If we get here, it was a coincidence.  We've wasted a
    			   few cycles, but don't abort.  */
    }
    ```

  - free를 할때, free 대상인 chunk->key 값이 tcache값(tcache_perthread_struct chunk의 주소)과 **"같으면"**  double free로 판단합니다.

- 즉,  ```e->key != tcache ```를 만족하면 tcahce double free 검증을 쉽게 우회할 수 있습니다.

- **우회 방법**

  - heap overflow를 통해 e->key값을 덮어버릴 수 있습니다.
  - free 후 ptr의 값이 초기화 되지 않아(UAF 취약점) free 후에도 해당 ptr에 접근하여 값을 조작할 수 있다면 가능합니다.

- double free를 성공시킨 이후 부터는 fd를 덮어 원하는 주소에 청크를 재할당시키는 기존의 방법 똑같이 하면 됩니다.

  - 할당하는 함수인 tcache_get은 ```e->key = NULL```로 초기화 하는 코드만 있을 뿐, ```e->key == tcache ```과 같은 검증하는 코드는 없기 때문입니다.



## Reference

Dreamhack.io 강의